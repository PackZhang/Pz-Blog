{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"themes/Anisina/source/css/blog-style.css","path":"css/blog-style.css","modified":0,"renderable":1},{"_id":"themes/Anisina/source/fonts/glyphicons-halflings-regular.eot","path":"fonts/glyphicons-halflings-regular.eot","modified":0,"renderable":1},{"_id":"themes/Anisina/source/css/syntax.styl","path":"css/syntax.styl","modified":0,"renderable":1},{"_id":"themes/Anisina/source/fonts/glyphicons-halflings-regular.ttf","path":"fonts/glyphicons-halflings-regular.ttf","modified":0,"renderable":1},{"_id":"themes/Anisina/source/fonts/glyphicons-halflings-regular.woff","path":"fonts/glyphicons-halflings-regular.woff","modified":0,"renderable":1},{"_id":"themes/Anisina/source/fonts/glyphicons-halflings-regular.woff2","path":"fonts/glyphicons-halflings-regular.woff2","modified":0,"renderable":1},{"_id":"themes/Anisina/source/js/blog.js","path":"js/blog.js","modified":0,"renderable":1},{"_id":"themes/Anisina/source/js/bootstrap.min.js","path":"js/bootstrap.min.js","modified":0,"renderable":1},{"_id":"themes/Anisina/source/js/totop.js","path":"js/totop.js","modified":0,"renderable":1},{"_id":"themes/Anisina/source/js/jquery.tagcloud.js","path":"js/jquery.tagcloud.js","modified":0,"renderable":1},{"_id":"themes/Anisina/source/css/bootstrap.min.css","path":"css/bootstrap.min.css","modified":0,"renderable":1},{"_id":"themes/Anisina/source/fonts/glyphicons-halflings-regular.svg","path":"fonts/glyphicons-halflings-regular.svg","modified":0,"renderable":1},{"_id":"themes/Anisina/source/js/jquery.min.js","path":"js/jquery.min.js","modified":0,"renderable":1},{"_id":"themes/Anisina/source/js/jquery.js","path":"js/jquery.js","modified":0,"renderable":1}],"Cache":[{"_id":"source/.DS_Store","hash":"42f3864ec17ef77f288da89ff697ebe052b0374b","modified":1494485454000},{"_id":"source/_posts/ReactiveCocoa-RACCommand.md","hash":"ce95dd3cf956a46cbb0e91cfaa8cd0eba0c4fab0","modified":1504685099000},{"_id":"source/_posts/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1496815462000},{"_id":"source/_posts/ReactiveCocoa-RACSignal.md","hash":"5a09941577f03bb0ca41e6fd17c9015cc5e9be91","modified":1504685099000},{"_id":"source/_posts/ReactiveCocoa-RACSubject.md","hash":"4a66a3c45e6ea22d2a481959e7f2cadea4eb7098","modified":1504685099000},{"_id":"source/_posts/ReactiveCocoa.md","hash":"c2f4b867a5fd572318120ad0b1719b6593a18458","modified":1504685099000},{"_id":"source/_posts/Xcode-忽略警告.md","hash":"ae7f97a021f7c461054a570bf986d083a3c44e7a","modified":1504685099000},{"_id":"source/_posts/为应用添加Touch-ID.md","hash":"f089ae3c7e50c918dc819ded864949573b9d751f","modified":1495006252000},{"_id":"source/_posts/小红点拖拽效果.md","hash":"815a26cfea259298430aa5fd99d4e78884bfc9f4","modified":1504685099000},{"_id":"themes/Anisina/README.md","hash":"ebde4101f083169abf82f5d9aa6fa34959d5cf11","modified":1499966658000},{"_id":"themes/Anisina/.DS_Store","hash":"be5d5c310d80b19adda21b95f325b96bd8b12f8f","modified":1499966658000},{"_id":"themes/Anisina/LICENSE","hash":"2b209f06bebeb2a8c2b7e187e436f3e1e1fbc8a7","modified":1499966658000},{"_id":"themes/Anisina/_config.yml","hash":"06bccfc42b143659f59ea78938f00c217ac5574d","modified":1499966658000},{"_id":"themes/Anisina/package.json","hash":"12541fbf56f785e4f5d486a55b4939f3033f625b","modified":1499966658000},{"_id":"themes/Anisina/.idea/modules.xml","hash":"6f81355dee5b607683bdbd56595a930fb4b83c8b","modified":1499966658000},{"_id":"themes/Anisina/.idea/Anisina.iml","hash":"4240dabdc746a36bae8a56eeec04a3a3fc59d842","modified":1499966658000},{"_id":"themes/Anisina/.idea/vcs.xml","hash":"c92f3eb0ad1c70371e177a4d7d741f90af3f902c","modified":1499966658000},{"_id":"themes/Anisina/.idea/workspace.xml","hash":"7c5d920658041056cc34836371895677b507001c","modified":1499966658000},{"_id":"themes/Anisina/Screenshots/mobile-index.jpeg","hash":"cd75f77f5d865d42182e2233e354eeba9f114d98","modified":1499966658000},{"_id":"themes/Anisina/languages_to_be_added/de.yml","hash":"424a9c1e6ab69334d7873f6574da02ca960aa572","modified":1499966658000},{"_id":"themes/Anisina/languages_to_be_added/default.yml","hash":"97326c9e6518d9f379778178b3b8f9a58434725d","modified":1499966658000},{"_id":"themes/Anisina/languages_to_be_added/en.yml","hash":"97326c9e6518d9f379778178b3b8f9a58434725d","modified":1499966658000},{"_id":"themes/Anisina/languages_to_be_added/es.yml","hash":"cb4eeca0ed3768a77e0cd216300f2b2549628b1b","modified":1499966658000},{"_id":"themes/Anisina/languages_to_be_added/no.yml","hash":"8ca475a3b4f8efe6603030f0013aae39668230e1","modified":1499966658000},{"_id":"themes/Anisina/languages_to_be_added/pl.yml","hash":"de7eb5850ae65ba7638e907c805fea90617a988c","modified":1499966658000},{"_id":"themes/Anisina/languages_to_be_added/ru.yml","hash":"42df7afeb7a35dc46d272b7f4fb880a9d9ebcaa5","modified":1499966658000},{"_id":"themes/Anisina/languages_to_be_added/zh-TW.yml","hash":"9acac6cc4f8002c3fa53ff69fb8cf66c915bd016","modified":1499966658000},{"_id":"themes/Anisina/languages_to_be_added/zh-CN.yml","hash":"7bfcb0b8e97d7e5edcfca8ab26d55d9da2573c1c","modified":1499966658000},{"_id":"themes/Anisina/layout/.DS_Store","hash":"f60423538e7d115abf8c86b365e85ad35b418b25","modified":1499966658000},{"_id":"themes/Anisina/layout/404.ejs","hash":"1fe05722bd1b32bbe0ae4e3e880866f935e0ae11","modified":1499966658000},{"_id":"themes/Anisina/layout/about.ejs","hash":"d409109a84aa5c032e1a230c973a91b293765176","modified":1499966658000},{"_id":"themes/Anisina/layout/archive.ejs","hash":"9233a4713382432b315f337adbf1db2b63082971","modified":1499966658000},{"_id":"themes/Anisina/layout/index.ejs","hash":"a94ac678f6b24a46824d45ec058b0ab2105a92c9","modified":1499966658000},{"_id":"themes/Anisina/layout/layout.ejs","hash":"b728827bf3ec55baf96a882032397e6c74c65f34","modified":1499966658000},{"_id":"themes/Anisina/layout/page.ejs","hash":"95bbc74aa6d10cddddd7a5cd5d2a06482f5ea173","modified":1499966658000},{"_id":"themes/Anisina/layout/poetry.ejs","hash":"6c955d419050825e13d39c780d45aceafbf6552d","modified":1499966658000},{"_id":"themes/Anisina/layout/tags.ejs","hash":"ff363455eeddfd389ecf6c5ab090408e1d2ef4e6","modified":1499966658000},{"_id":"themes/Anisina/layout/works.ejs","hash":"1df954e54098cc4845295836374abed870789dcd","modified":1499966658000},{"_id":"themes/Anisina/layout/post.ejs","hash":"9427ac91b2bc36c339b528d9a569c038f0b18efa","modified":1499966658000},{"_id":"themes/Anisina/.idea/inspectionProfiles/Project_Default.xml","hash":"cb98213afbdfab7620cd4b6ba8801035079b4ae5","modified":1499966658000},{"_id":"themes/Anisina/Screenshots/Anisina.png","hash":"146dd991f55a827a514259e20a51de1e9b07a13d","modified":1499966658000},{"_id":"themes/Anisina/layout/_partial/footer.ejs","hash":"223a29b0154c2dcc5f8a6b6fee67ef78ead266ad","modified":1499966658000},{"_id":"themes/Anisina/layout/_partial/head.ejs","hash":"4e0d96cac503d4e3a5b254d8b8175c392971ce38","modified":1499966658000},{"_id":"themes/Anisina/layout/_partial/nav.ejs","hash":"3baa41d595e951efa1db34dd1789c6f8d3b094da","modified":1499966658000},{"_id":"themes/Anisina/layout/_partial/pagination.ejs","hash":"557d6bb069a1d48af49ae912994653f44b32a570","modified":1499966658000},{"_id":"themes/Anisina/source/css/blog-style.css","hash":"c6830e31138e412c2aa05228c4cd6035063fe651","modified":1499966658000},{"_id":"themes/Anisina/source/fonts/glyphicons-halflings-regular.eot","hash":"86b6f62b7853e67d3e635f6512a5a5efc58ea3c3","modified":1499966658000},{"_id":"themes/Anisina/source/css/syntax.styl","hash":"f3f9ff0d1ebc4f7fa18d7e367b2ba2f0899adbd4","modified":1499966658000},{"_id":"themes/Anisina/source/fonts/glyphicons-halflings-regular.ttf","hash":"44bc1850f570972267b169ae18f1cb06b611ffa2","modified":1499966658000},{"_id":"themes/Anisina/source/fonts/glyphicons-halflings-regular.woff","hash":"278e49a86e634da6f2a02f3b47dd9d2a8f26210f","modified":1499966658000},{"_id":"themes/Anisina/source/fonts/glyphicons-halflings-regular.woff2","hash":"ca35b697d99cae4d1b60f2d60fcd37771987eb07","modified":1499966658000},{"_id":"themes/Anisina/source/js/blog.js","hash":"0f805c744ef8a48c0abdd9d204cfc19ee6cafc14","modified":1499966658000},{"_id":"themes/Anisina/source/js/bootstrap.min.js","hash":"b3f2ef9f985e7906c9360756b73cd64bf7733647","modified":1499966658000},{"_id":"themes/Anisina/source/js/totop.js","hash":"11ede60fccb7c763d6973f80efc78b47c0843746","modified":1499966658000},{"_id":"themes/Anisina/source/js/jquery.tagcloud.js","hash":"4e5fd0b07f3bd935f2e603710447e039e3677211","modified":1499966658000},{"_id":"themes/Anisina/Screenshots/poetry-show.png","hash":"f5fdcd25026a87a0aafeebb1f19cdb3c0a81a666","modified":1499966658000},{"_id":"themes/Anisina/source/css/bootstrap.min.css","hash":"c5db932e115ff97af7b4512b947cde3ba2964db8","modified":1499966658000},{"_id":"themes/Anisina/source/fonts/glyphicons-halflings-regular.svg","hash":"de51a8494180a6db074af2dee2383f0a363c5b08","modified":1499966658000},{"_id":"themes/Anisina/source/js/jquery.min.js","hash":"41b4bfbaa96be6d1440db6e78004ade1c134e276","modified":1499966658000},{"_id":"themes/Anisina/Screenshots/mobile-post.jpeg","hash":"2081cdff23a9a8c185a48d9aabcc9dc8e77833ec","modified":1499966658000},{"_id":"themes/Anisina/source/js/jquery.js","hash":"1852661bd11a09ca9b9cb63d1aa6ff390fffaf4e","modified":1499966658000},{"_id":"themes/Anisina/Screenshots/pc-index.png","hash":"b04094dac75cb656b4244c1dfaf246168a0f8926","modified":1499966658000},{"_id":"themes/Anisina/Screenshots/pc-post.png","hash":"cde56c0797b6ff8dd555fb1f8c3f9b21bceaa3be","modified":1499966658000}],"Category":[],"Data":[],"Page":[],"Post":[{"title":"ReactiveCocoa之核心信号---RACCommand","date":"2017-05-31T02:46:52.000Z","_content":"\n`Command`的意思为指令的意思，在使用RAC时是经常使用到类。它主要可以处理响应事件，耗时操作等。\n\n## 给按钮添加操作\nRAC使用分类给UIBarButtonItem，UIButton等控件做了支持，可以方便我们使用RAC给它们添加操作。用到的类是RACCommand。\n\n```objectivec\n@weakify(self);\n    self.samplePicButton.rac_command = [[RACCommand alloc] initWithSignalBlock:^RACSignal *(id input) {\n        @strongify(self);\n        [self showSamplePic];\n        \n        return [RACSignal empty];\n    }];\n```\n\n使用原来给按钮添加操作的方法`- (void)addTarget:(nullable id)target action:(SEL)action forControlEvents:(UIControlEvents)controlEvents;`，就会发现两个问题\n\n1.需要额外定义方法，过程繁琐。  \n2.不利于阅读，需要跳转到action的具体实现。\n\n使用RAC提供的方法，完美解决了以上问题并且符合编码高内聚的思想。\n\n## 执行网络操作\n#### 创建命令\n`RACCommand`还支持手动创建，然后在需要的时候执行。\n\n```\nmarketingDataCommand = [[RACCommand alloc] initWithSignalBlock:^RACSignal *(id input) {\n    return [self MarketingDataSignal];\n}];\n```\n\n在SignalBlock中需要返回一个`RACSignal`对象，RACSignal对象封装了网络请求。\n\n```\n- (RACSignal *)MarketingDataSignal {\n    return [RACSignal createSignal:^RACDisposable *(id<RACSubscriber> subscriber) {\n        [MarketingRequestModel marketingDataSuccess:^(id object) {\n            \n            MarketingDataViewModel *vm = [[MarketingDataViewModel alloc] init];\n            vm.model = object;\n            self.marketingVM = vm;\n            \n            [subscriber sendNext:nil];\n            [subscriber sendCompleted];\n        } Failure:^{\n            [subscriber sendCompleted];\n        }];\n        return nil;\n    }];\n}\n```\n\n以上代码可以的操作就是创建信号，信号内部调用`marketingDataSuccess `网络请求，无论成功还是失败都给订阅者`send`信息。\n\n在外部如何去调用`RACCommand`呢？\n\n在外部需要对`RACCommand `做两件事情，那就是`触发`与`订阅`。\n\n#### 触发\n对`RACCommand `的触发非常简单。\n\n```\n[marketingDataCommand execute:nil];\n```\n执行`execute `方法的时候，就会去执行`RACCommand`创建时的`signalBlock`闭包中的内容。\n\n#### 订阅\n触发`RACCommand `以后通常需要视图层有感知，例如舒刷新表格，停止动画等。订阅`RACCommand`中的信号即可。\n\n```\n[self.marketingVM.marketingDataCommand.executionSignals subscribeNext:^(RACSignal *signal) {\n    [signal subscribeNext:^(id x) {\n        //do something\n     }];\n}];\n```\n`executionSignals`会获取到信号的信号，在对信号进行订阅，也可以写成以下简化的形式。\n\n```\n[marketingDataCommand.executionSignals.switchToLatest subscribeNext:^(id x) {\n    //do something\n}];\n```\n\n\n#### 传递参数\n在触发命令的时候(执行`- (RACSignal *)execute:(id)input`方法)，可以传入`input`参数。会作为`RACCommand`创建时的`signalBlock`闭包的参数传入。\n***\n在MVVM+RAC的架构中，`RACCommand `常暴露在`ViewModel`的.h文件中，以供给外部View层调用。而在`RACCommand`中的操作通常则是网络请求或者数据存储。\n","source":"_posts/ReactiveCocoa-RACCommand.md","raw":"---\ntitle: ReactiveCocoa之核心信号---RACCommand\ndate: 2017-05-31 10:46:52\ntags: ReactiveCocoa\n---\n\n`Command`的意思为指令的意思，在使用RAC时是经常使用到类。它主要可以处理响应事件，耗时操作等。\n\n## 给按钮添加操作\nRAC使用分类给UIBarButtonItem，UIButton等控件做了支持，可以方便我们使用RAC给它们添加操作。用到的类是RACCommand。\n\n```objectivec\n@weakify(self);\n    self.samplePicButton.rac_command = [[RACCommand alloc] initWithSignalBlock:^RACSignal *(id input) {\n        @strongify(self);\n        [self showSamplePic];\n        \n        return [RACSignal empty];\n    }];\n```\n\n使用原来给按钮添加操作的方法`- (void)addTarget:(nullable id)target action:(SEL)action forControlEvents:(UIControlEvents)controlEvents;`，就会发现两个问题\n\n1.需要额外定义方法，过程繁琐。  \n2.不利于阅读，需要跳转到action的具体实现。\n\n使用RAC提供的方法，完美解决了以上问题并且符合编码高内聚的思想。\n\n## 执行网络操作\n#### 创建命令\n`RACCommand`还支持手动创建，然后在需要的时候执行。\n\n```\nmarketingDataCommand = [[RACCommand alloc] initWithSignalBlock:^RACSignal *(id input) {\n    return [self MarketingDataSignal];\n}];\n```\n\n在SignalBlock中需要返回一个`RACSignal`对象，RACSignal对象封装了网络请求。\n\n```\n- (RACSignal *)MarketingDataSignal {\n    return [RACSignal createSignal:^RACDisposable *(id<RACSubscriber> subscriber) {\n        [MarketingRequestModel marketingDataSuccess:^(id object) {\n            \n            MarketingDataViewModel *vm = [[MarketingDataViewModel alloc] init];\n            vm.model = object;\n            self.marketingVM = vm;\n            \n            [subscriber sendNext:nil];\n            [subscriber sendCompleted];\n        } Failure:^{\n            [subscriber sendCompleted];\n        }];\n        return nil;\n    }];\n}\n```\n\n以上代码可以的操作就是创建信号，信号内部调用`marketingDataSuccess `网络请求，无论成功还是失败都给订阅者`send`信息。\n\n在外部如何去调用`RACCommand`呢？\n\n在外部需要对`RACCommand `做两件事情，那就是`触发`与`订阅`。\n\n#### 触发\n对`RACCommand `的触发非常简单。\n\n```\n[marketingDataCommand execute:nil];\n```\n执行`execute `方法的时候，就会去执行`RACCommand`创建时的`signalBlock`闭包中的内容。\n\n#### 订阅\n触发`RACCommand `以后通常需要视图层有感知，例如舒刷新表格，停止动画等。订阅`RACCommand`中的信号即可。\n\n```\n[self.marketingVM.marketingDataCommand.executionSignals subscribeNext:^(RACSignal *signal) {\n    [signal subscribeNext:^(id x) {\n        //do something\n     }];\n}];\n```\n`executionSignals`会获取到信号的信号，在对信号进行订阅，也可以写成以下简化的形式。\n\n```\n[marketingDataCommand.executionSignals.switchToLatest subscribeNext:^(id x) {\n    //do something\n}];\n```\n\n\n#### 传递参数\n在触发命令的时候(执行`- (RACSignal *)execute:(id)input`方法)，可以传入`input`参数。会作为`RACCommand`创建时的`signalBlock`闭包的参数传入。\n***\n在MVVM+RAC的架构中，`RACCommand `常暴露在`ViewModel`的.h文件中，以供给外部View层调用。而在`RACCommand`中的操作通常则是网络请求或者数据存储。\n","slug":"ReactiveCocoa-RACCommand","published":1,"updated":"2017-09-06T08:04:59.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj78qu5tb0000s2u9d8ahga7d","content":"<p><code>Command</code>的意思为指令的意思，在使用RAC时是经常使用到类。它主要可以处理响应事件，耗时操作等。</p>\n<h2 id=\"给按钮添加操作\"><a href=\"#给按钮添加操作\" class=\"headerlink\" title=\"给按钮添加操作\"></a>给按钮添加操作</h2><p>RAC使用分类给UIBarButtonItem，UIButton等控件做了支持，可以方便我们使用RAC给它们添加操作。用到的类是RACCommand。</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"code\"><pre><div class=\"line\">@weakify(<span class=\"keyword\">self</span>);</div><div class=\"line\">    <span class=\"keyword\">self</span>.samplePicButton.rac_command = [[RACCommand alloc] initWithSignalBlock:^RACSignal *(<span class=\"keyword\">id</span> input) &#123;</div><div class=\"line\">        @strongify(<span class=\"keyword\">self</span>);</div><div class=\"line\">        [<span class=\"keyword\">self</span> showSamplePic];</div><div class=\"line\">        </div><div class=\"line\">        <span class=\"keyword\">return</span> [RACSignal empty];</div><div class=\"line\">    &#125;];</div></pre></td></tr></table></figure>\n<p>使用原来给按钮添加操作的方法<code>- (void)addTarget:(nullable id)target action:(SEL)action forControlEvents:(UIControlEvents)controlEvents;</code>，就会发现两个问题</p>\n<p>1.需要额外定义方法，过程繁琐。<br>2.不利于阅读，需要跳转到action的具体实现。</p>\n<p>使用RAC提供的方法，完美解决了以上问题并且符合编码高内聚的思想。</p>\n<h2 id=\"执行网络操作\"><a href=\"#执行网络操作\" class=\"headerlink\" title=\"执行网络操作\"></a>执行网络操作</h2><h4 id=\"创建命令\"><a href=\"#创建命令\" class=\"headerlink\" title=\"创建命令\"></a>创建命令</h4><p><code>RACCommand</code>还支持手动创建，然后在需要的时候执行。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">marketingDataCommand = [[RACCommand alloc] initWithSignalBlock:^RACSignal *(id input) &#123;</div><div class=\"line\">    return [self MarketingDataSignal];</div><div class=\"line\">&#125;];</div></pre></td></tr></table></figure>\n<p>在SignalBlock中需要返回一个<code>RACSignal</code>对象，RACSignal对象封装了网络请求。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">- (RACSignal *)MarketingDataSignal &#123;</div><div class=\"line\">    return [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123;</div><div class=\"line\">        [MarketingRequestModel marketingDataSuccess:^(id object) &#123;</div><div class=\"line\">            </div><div class=\"line\">            MarketingDataViewModel *vm = [[MarketingDataViewModel alloc] init];</div><div class=\"line\">            vm.model = object;</div><div class=\"line\">            self.marketingVM = vm;</div><div class=\"line\">            </div><div class=\"line\">            [subscriber sendNext:nil];</div><div class=\"line\">            [subscriber sendCompleted];</div><div class=\"line\">        &#125; Failure:^&#123;</div><div class=\"line\">            [subscriber sendCompleted];</div><div class=\"line\">        &#125;];</div><div class=\"line\">        return nil;</div><div class=\"line\">    &#125;];</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>以上代码可以的操作就是创建信号，信号内部调用<code>marketingDataSuccess</code>网络请求，无论成功还是失败都给订阅者<code>send</code>信息。</p>\n<p>在外部如何去调用<code>RACCommand</code>呢？</p>\n<p>在外部需要对<code>RACCommand</code>做两件事情，那就是<code>触发</code>与<code>订阅</code>。</p>\n<h4 id=\"触发\"><a href=\"#触发\" class=\"headerlink\" title=\"触发\"></a>触发</h4><p>对<code>RACCommand</code>的触发非常简单。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">[marketingDataCommand execute:nil];</div></pre></td></tr></table></figure>\n<p>执行<code>execute</code>方法的时候，就会去执行<code>RACCommand</code>创建时的<code>signalBlock</code>闭包中的内容。</p>\n<h4 id=\"订阅\"><a href=\"#订阅\" class=\"headerlink\" title=\"订阅\"></a>订阅</h4><p>触发<code>RACCommand</code>以后通常需要视图层有感知，例如舒刷新表格，停止动画等。订阅<code>RACCommand</code>中的信号即可。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">[self.marketingVM.marketingDataCommand.executionSignals subscribeNext:^(RACSignal *signal) &#123;</div><div class=\"line\">    [signal subscribeNext:^(id x) &#123;</div><div class=\"line\">        //do something</div><div class=\"line\">     &#125;];</div><div class=\"line\">&#125;];</div></pre></td></tr></table></figure>\n<p><code>executionSignals</code>会获取到信号的信号，在对信号进行订阅，也可以写成以下简化的形式。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">[marketingDataCommand.executionSignals.switchToLatest subscribeNext:^(id x) &#123;</div><div class=\"line\">    //do something</div><div class=\"line\">&#125;];</div></pre></td></tr></table></figure>\n<h4 id=\"传递参数\"><a href=\"#传递参数\" class=\"headerlink\" title=\"传递参数\"></a>传递参数</h4><p>在触发命令的时候(执行<code>- (RACSignal *)execute:(id)input</code>方法)，可以传入<code>input</code>参数。会作为<code>RACCommand</code>创建时的<code>signalBlock</code>闭包的参数传入。</p>\n<hr>\n<p>在MVVM+RAC的架构中，<code>RACCommand</code>常暴露在<code>ViewModel</code>的.h文件中，以供给外部View层调用。而在<code>RACCommand</code>中的操作通常则是网络请求或者数据存储。</p>\n","site":{"data":{}},"excerpt":"","more":"<p><code>Command</code>的意思为指令的意思，在使用RAC时是经常使用到类。它主要可以处理响应事件，耗时操作等。</p>\n<h2 id=\"给按钮添加操作\"><a href=\"#给按钮添加操作\" class=\"headerlink\" title=\"给按钮添加操作\"></a>给按钮添加操作</h2><p>RAC使用分类给UIBarButtonItem，UIButton等控件做了支持，可以方便我们使用RAC给它们添加操作。用到的类是RACCommand。</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"code\"><pre><div class=\"line\">@weakify(<span class=\"keyword\">self</span>);</div><div class=\"line\">    <span class=\"keyword\">self</span>.samplePicButton.rac_command = [[RACCommand alloc] initWithSignalBlock:^RACSignal *(<span class=\"keyword\">id</span> input) &#123;</div><div class=\"line\">        @strongify(<span class=\"keyword\">self</span>);</div><div class=\"line\">        [<span class=\"keyword\">self</span> showSamplePic];</div><div class=\"line\">        </div><div class=\"line\">        <span class=\"keyword\">return</span> [RACSignal empty];</div><div class=\"line\">    &#125;];</div></pre></td></tr></table></figure>\n<p>使用原来给按钮添加操作的方法<code>- (void)addTarget:(nullable id)target action:(SEL)action forControlEvents:(UIControlEvents)controlEvents;</code>，就会发现两个问题</p>\n<p>1.需要额外定义方法，过程繁琐。<br>2.不利于阅读，需要跳转到action的具体实现。</p>\n<p>使用RAC提供的方法，完美解决了以上问题并且符合编码高内聚的思想。</p>\n<h2 id=\"执行网络操作\"><a href=\"#执行网络操作\" class=\"headerlink\" title=\"执行网络操作\"></a>执行网络操作</h2><h4 id=\"创建命令\"><a href=\"#创建命令\" class=\"headerlink\" title=\"创建命令\"></a>创建命令</h4><p><code>RACCommand</code>还支持手动创建，然后在需要的时候执行。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">marketingDataCommand = [[RACCommand alloc] initWithSignalBlock:^RACSignal *(id input) &#123;</div><div class=\"line\">    return [self MarketingDataSignal];</div><div class=\"line\">&#125;];</div></pre></td></tr></table></figure>\n<p>在SignalBlock中需要返回一个<code>RACSignal</code>对象，RACSignal对象封装了网络请求。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">- (RACSignal *)MarketingDataSignal &#123;</div><div class=\"line\">    return [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123;</div><div class=\"line\">        [MarketingRequestModel marketingDataSuccess:^(id object) &#123;</div><div class=\"line\">            </div><div class=\"line\">            MarketingDataViewModel *vm = [[MarketingDataViewModel alloc] init];</div><div class=\"line\">            vm.model = object;</div><div class=\"line\">            self.marketingVM = vm;</div><div class=\"line\">            </div><div class=\"line\">            [subscriber sendNext:nil];</div><div class=\"line\">            [subscriber sendCompleted];</div><div class=\"line\">        &#125; Failure:^&#123;</div><div class=\"line\">            [subscriber sendCompleted];</div><div class=\"line\">        &#125;];</div><div class=\"line\">        return nil;</div><div class=\"line\">    &#125;];</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>以上代码可以的操作就是创建信号，信号内部调用<code>marketingDataSuccess</code>网络请求，无论成功还是失败都给订阅者<code>send</code>信息。</p>\n<p>在外部如何去调用<code>RACCommand</code>呢？</p>\n<p>在外部需要对<code>RACCommand</code>做两件事情，那就是<code>触发</code>与<code>订阅</code>。</p>\n<h4 id=\"触发\"><a href=\"#触发\" class=\"headerlink\" title=\"触发\"></a>触发</h4><p>对<code>RACCommand</code>的触发非常简单。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">[marketingDataCommand execute:nil];</div></pre></td></tr></table></figure>\n<p>执行<code>execute</code>方法的时候，就会去执行<code>RACCommand</code>创建时的<code>signalBlock</code>闭包中的内容。</p>\n<h4 id=\"订阅\"><a href=\"#订阅\" class=\"headerlink\" title=\"订阅\"></a>订阅</h4><p>触发<code>RACCommand</code>以后通常需要视图层有感知，例如舒刷新表格，停止动画等。订阅<code>RACCommand</code>中的信号即可。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">[self.marketingVM.marketingDataCommand.executionSignals subscribeNext:^(RACSignal *signal) &#123;</div><div class=\"line\">    [signal subscribeNext:^(id x) &#123;</div><div class=\"line\">        //do something</div><div class=\"line\">     &#125;];</div><div class=\"line\">&#125;];</div></pre></td></tr></table></figure>\n<p><code>executionSignals</code>会获取到信号的信号，在对信号进行订阅，也可以写成以下简化的形式。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">[marketingDataCommand.executionSignals.switchToLatest subscribeNext:^(id x) &#123;</div><div class=\"line\">    //do something</div><div class=\"line\">&#125;];</div></pre></td></tr></table></figure>\n<h4 id=\"传递参数\"><a href=\"#传递参数\" class=\"headerlink\" title=\"传递参数\"></a>传递参数</h4><p>在触发命令的时候(执行<code>- (RACSignal *)execute:(id)input</code>方法)，可以传入<code>input</code>参数。会作为<code>RACCommand</code>创建时的<code>signalBlock</code>闭包的参数传入。</p>\n<hr>\n<p>在MVVM+RAC的架构中，<code>RACCommand</code>常暴露在<code>ViewModel</code>的.h文件中，以供给外部View层调用。而在<code>RACCommand</code>中的操作通常则是网络请求或者数据存储。</p>\n"},{"title":"ReactiveCocoa之核心信号---RACSignal","date":"2017-05-17T06:48:46.000Z","_content":"## 创建信号\n\n```objectivec\nRACSignal *signal = [RACSignal createSignal:^RACDisposable * _Nullable(id<RACSubscriber>  _Nonnull subscriber) {\n       \n        //被订阅时触发闭包\n        //发送信号给订阅者\n        [subscriber sendNext:@1];\n        [subscriber sendNext:@2];\n        [subscriber sendNext:@3];\n        \n        [subscriber sendCompleted];\n        \n        return [RACDisposable disposableWithBlock:^{\n            NSLog(@\"信号销毁\");\n        }];\n    }];\n```\n\n`createSignal `最终会调用到以下`RACDynamicSignal`类的对象方法\n\n```objectivec\n+ (RACSignal *)createSignal:(RACDisposable * (^)(id<RACSubscriber> subscriber))didSubscribe {\n\tRACDynamicSignal *signal = [[self alloc] init];\n\tsignal->_didSubscribe = [didSubscribe copy];\n\treturn [signal setNameWithFormat:@\"+createSignal:\"];\n}\n```\n\n可以看出这个方法做的事情非常简单，创建Signal对象，并将didSubscribe代码块保存起来。\n\n> 值得注意的是每一个信号的终点都是complete或者error，否则下一次对信号订阅操作不会生效。\n\n## 订阅信号\n```objectivec\n\t//订阅信号\n    [signal subscribeNext:^(id  _Nullable x) {\n        //接收到信号时触发闭包\n        NSLog(@\"%@\",x);\n    }];\n```\n`subscribeNext `方法对刚才创建的signal进行订阅操作，`subscribeNext `的实现如下\n\n```objectivec\n- (RACDisposable *)subscribeNext:(void (^)(id x))nextBlock {\n\tNSCParameterAssert(nextBlock != NULL);\n\t\n\tRACSubscriber *o = [RACSubscriber subscriberWithNext:nextBlock error:NULL completed:NULL];\n\treturn [self subscribe:o];\n}\n\n- (RACDisposable *)subscribe:(id<RACSubscriber>)subscriber {\n\tNSCParameterAssert(subscriber != nil);\n\n\tRACCompoundDisposable *disposable = [RACCompoundDisposable compoundDisposable];\n\tsubscriber = [[RACPassthroughSubscriber alloc] initWithSubscriber:subscriber signal:self disposable:disposable];\n\n\tif (self.didSubscribe != NULL) {\n\t\tRACDisposable *schedulingDisposable = [RACScheduler.subscriptionScheduler schedule:^{\n\t\t\tRACDisposable *innerDisposable = self.didSubscribe(subscriber);\n\t\t\t[disposable addDisposable:innerDisposable];\n\t\t}];\n\n\t\t[disposable addDisposable:schedulingDisposable];\n\t}\n\t\n\treturn disposable;\n}\n\n```\n内部会创建订阅者并且保存`nextBlock `代码快中的代码，并且进入到`RACDynamicSignal `的`subscribe `方法中执行在创建信号时保存的`didSubscribe `代码块中保存的代码。\n在`didSubscribe `中已经写好了`[subscriber sendNext:@1];`方法，`sendNext`的实现如下\n\n```objectivec\n- (void)sendNext:(id)value {\n\t@synchronized (self) {\n\t\tvoid (^nextBlock)(id) = [self.next copy];\n\t\tif (nextBlock == nil) return;\n\n\t\tnextBlock(value);\n\t}\n}\n```\n在执行`sendNext`方法时会执行在订阅信号时保存的`nextBlock `代码，将数字1打印出来。\n","source":"_posts/ReactiveCocoa-RACSignal.md","raw":"---\ntitle: ReactiveCocoa之核心信号---RACSignal\ndate: 2017-05-17 14:48:46\ntags: \n- ReactiveCocoa\n---\n## 创建信号\n\n```objectivec\nRACSignal *signal = [RACSignal createSignal:^RACDisposable * _Nullable(id<RACSubscriber>  _Nonnull subscriber) {\n       \n        //被订阅时触发闭包\n        //发送信号给订阅者\n        [subscriber sendNext:@1];\n        [subscriber sendNext:@2];\n        [subscriber sendNext:@3];\n        \n        [subscriber sendCompleted];\n        \n        return [RACDisposable disposableWithBlock:^{\n            NSLog(@\"信号销毁\");\n        }];\n    }];\n```\n\n`createSignal `最终会调用到以下`RACDynamicSignal`类的对象方法\n\n```objectivec\n+ (RACSignal *)createSignal:(RACDisposable * (^)(id<RACSubscriber> subscriber))didSubscribe {\n\tRACDynamicSignal *signal = [[self alloc] init];\n\tsignal->_didSubscribe = [didSubscribe copy];\n\treturn [signal setNameWithFormat:@\"+createSignal:\"];\n}\n```\n\n可以看出这个方法做的事情非常简单，创建Signal对象，并将didSubscribe代码块保存起来。\n\n> 值得注意的是每一个信号的终点都是complete或者error，否则下一次对信号订阅操作不会生效。\n\n## 订阅信号\n```objectivec\n\t//订阅信号\n    [signal subscribeNext:^(id  _Nullable x) {\n        //接收到信号时触发闭包\n        NSLog(@\"%@\",x);\n    }];\n```\n`subscribeNext `方法对刚才创建的signal进行订阅操作，`subscribeNext `的实现如下\n\n```objectivec\n- (RACDisposable *)subscribeNext:(void (^)(id x))nextBlock {\n\tNSCParameterAssert(nextBlock != NULL);\n\t\n\tRACSubscriber *o = [RACSubscriber subscriberWithNext:nextBlock error:NULL completed:NULL];\n\treturn [self subscribe:o];\n}\n\n- (RACDisposable *)subscribe:(id<RACSubscriber>)subscriber {\n\tNSCParameterAssert(subscriber != nil);\n\n\tRACCompoundDisposable *disposable = [RACCompoundDisposable compoundDisposable];\n\tsubscriber = [[RACPassthroughSubscriber alloc] initWithSubscriber:subscriber signal:self disposable:disposable];\n\n\tif (self.didSubscribe != NULL) {\n\t\tRACDisposable *schedulingDisposable = [RACScheduler.subscriptionScheduler schedule:^{\n\t\t\tRACDisposable *innerDisposable = self.didSubscribe(subscriber);\n\t\t\t[disposable addDisposable:innerDisposable];\n\t\t}];\n\n\t\t[disposable addDisposable:schedulingDisposable];\n\t}\n\t\n\treturn disposable;\n}\n\n```\n内部会创建订阅者并且保存`nextBlock `代码快中的代码，并且进入到`RACDynamicSignal `的`subscribe `方法中执行在创建信号时保存的`didSubscribe `代码块中保存的代码。\n在`didSubscribe `中已经写好了`[subscriber sendNext:@1];`方法，`sendNext`的实现如下\n\n```objectivec\n- (void)sendNext:(id)value {\n\t@synchronized (self) {\n\t\tvoid (^nextBlock)(id) = [self.next copy];\n\t\tif (nextBlock == nil) return;\n\n\t\tnextBlock(value);\n\t}\n}\n```\n在执行`sendNext`方法时会执行在订阅信号时保存的`nextBlock `代码，将数字1打印出来。\n","slug":"ReactiveCocoa-RACSignal","published":1,"updated":"2017-09-06T08:04:59.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj78qu5tg0001s2u90w4fm3u2","content":"<h2 id=\"创建信号\"><a href=\"#创建信号\" class=\"headerlink\" title=\"创建信号\"></a>创建信号</h2><figure class=\"highlight objectivec\"><table><tr><td class=\"code\"><pre><div class=\"line\">RACSignal *signal = [RACSignal createSignal:^RACDisposable * _Nullable(<span class=\"keyword\">id</span>&lt;RACSubscriber&gt;  _Nonnull subscriber) &#123;</div><div class=\"line\">       </div><div class=\"line\">        <span class=\"comment\">//被订阅时触发闭包</span></div><div class=\"line\">        <span class=\"comment\">//发送信号给订阅者</span></div><div class=\"line\">        [subscriber sendNext:@<span class=\"number\">1</span>];</div><div class=\"line\">        [subscriber sendNext:@<span class=\"number\">2</span>];</div><div class=\"line\">        [subscriber sendNext:@<span class=\"number\">3</span>];</div><div class=\"line\">        </div><div class=\"line\">        [subscriber sendCompleted];</div><div class=\"line\">        </div><div class=\"line\">        <span class=\"keyword\">return</span> [RACDisposable disposableWithBlock:^&#123;</div><div class=\"line\">            <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"信号销毁\"</span>);</div><div class=\"line\">        &#125;];</div><div class=\"line\">    &#125;];</div></pre></td></tr></table></figure>\n<p><code>createSignal</code>最终会调用到以下<code>RACDynamicSignal</code>类的对象方法</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"code\"><pre><div class=\"line\">+ (RACSignal *)createSignal:(RACDisposable * (^)(<span class=\"keyword\">id</span>&lt;RACSubscriber&gt; subscriber))didSubscribe &#123;</div><div class=\"line\">\tRACDynamicSignal *signal = [[<span class=\"keyword\">self</span> alloc] init];</div><div class=\"line\">\tsignal-&gt;_didSubscribe = [didSubscribe <span class=\"keyword\">copy</span>];</div><div class=\"line\">\t<span class=\"keyword\">return</span> [signal setNameWithFormat:<span class=\"string\">@\"+createSignal:\"</span>];</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>可以看出这个方法做的事情非常简单，创建Signal对象，并将didSubscribe代码块保存起来。</p>\n<blockquote>\n<p>值得注意的是每一个信号的终点都是complete或者error，否则下一次对信号订阅操作不会生效。</p>\n</blockquote>\n<h2 id=\"订阅信号\"><a href=\"#订阅信号\" class=\"headerlink\" title=\"订阅信号\"></a>订阅信号</h2><figure class=\"highlight objectivec\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//订阅信号</span></div><div class=\"line\">   [signal subscribeNext:^(<span class=\"keyword\">id</span>  _Nullable x) &#123;</div><div class=\"line\">       <span class=\"comment\">//接收到信号时触发闭包</span></div><div class=\"line\">       <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%@\"</span>,x);</div><div class=\"line\">   &#125;];</div></pre></td></tr></table></figure>\n<p><code>subscribeNext</code>方法对刚才创建的signal进行订阅操作，<code>subscribeNext</code>的实现如下</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"code\"><pre><div class=\"line\">- (RACDisposable *)subscribeNext:(<span class=\"keyword\">void</span> (^)(<span class=\"keyword\">id</span> x))nextBlock &#123;</div><div class=\"line\">\t<span class=\"built_in\">NSCParameterAssert</span>(nextBlock != <span class=\"literal\">NULL</span>);</div><div class=\"line\">\t</div><div class=\"line\">\tRACSubscriber *o = [RACSubscriber subscriberWithNext:nextBlock error:<span class=\"literal\">NULL</span> completed:<span class=\"literal\">NULL</span>];</div><div class=\"line\">\t<span class=\"keyword\">return</span> [<span class=\"keyword\">self</span> subscribe:o];</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">- (RACDisposable *)subscribe:(<span class=\"keyword\">id</span>&lt;RACSubscriber&gt;)subscriber &#123;</div><div class=\"line\">\t<span class=\"built_in\">NSCParameterAssert</span>(subscriber != <span class=\"literal\">nil</span>);</div><div class=\"line\"></div><div class=\"line\">\tRACCompoundDisposable *disposable = [RACCompoundDisposable compoundDisposable];</div><div class=\"line\">\tsubscriber = [[RACPassthroughSubscriber alloc] initWithSubscriber:subscriber signal:<span class=\"keyword\">self</span> disposable:disposable];</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"keyword\">if</span> (<span class=\"keyword\">self</span>.didSubscribe != <span class=\"literal\">NULL</span>) &#123;</div><div class=\"line\">\t\tRACDisposable *schedulingDisposable = [RACScheduler.subscriptionScheduler schedule:^&#123;</div><div class=\"line\">\t\t\tRACDisposable *innerDisposable = <span class=\"keyword\">self</span>.didSubscribe(subscriber);</div><div class=\"line\">\t\t\t[disposable addDisposable:innerDisposable];</div><div class=\"line\">\t\t&#125;];</div><div class=\"line\"></div><div class=\"line\">\t\t[disposable addDisposable:schedulingDisposable];</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t</div><div class=\"line\">\t<span class=\"keyword\">return</span> disposable;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>内部会创建订阅者并且保存<code>nextBlock</code>代码快中的代码，并且进入到<code>RACDynamicSignal</code>的<code>subscribe</code>方法中执行在创建信号时保存的<code>didSubscribe</code>代码块中保存的代码。<br>在<code>didSubscribe</code>中已经写好了<code>[subscriber sendNext:@1];</code>方法，<code>sendNext</code>的实现如下</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"code\"><pre><div class=\"line\">- (<span class=\"keyword\">void</span>)sendNext:(<span class=\"keyword\">id</span>)value &#123;</div><div class=\"line\">\t<span class=\"keyword\">@synchronized</span> (<span class=\"keyword\">self</span>) &#123;</div><div class=\"line\">\t\t<span class=\"keyword\">void</span> (^nextBlock)(<span class=\"keyword\">id</span>) = [<span class=\"keyword\">self</span>.next <span class=\"keyword\">copy</span>];</div><div class=\"line\">\t\t<span class=\"keyword\">if</span> (nextBlock == <span class=\"literal\">nil</span>) <span class=\"keyword\">return</span>;</div><div class=\"line\"></div><div class=\"line\">\t\tnextBlock(value);</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>在执行<code>sendNext</code>方法时会执行在订阅信号时保存的<code>nextBlock</code>代码，将数字1打印出来。</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"创建信号\"><a href=\"#创建信号\" class=\"headerlink\" title=\"创建信号\"></a>创建信号</h2><figure class=\"highlight objectivec\"><table><tr><td class=\"code\"><pre><div class=\"line\">RACSignal *signal = [RACSignal createSignal:^RACDisposable * _Nullable(<span class=\"keyword\">id</span>&lt;RACSubscriber&gt;  _Nonnull subscriber) &#123;</div><div class=\"line\">       </div><div class=\"line\">        <span class=\"comment\">//被订阅时触发闭包</span></div><div class=\"line\">        <span class=\"comment\">//发送信号给订阅者</span></div><div class=\"line\">        [subscriber sendNext:@<span class=\"number\">1</span>];</div><div class=\"line\">        [subscriber sendNext:@<span class=\"number\">2</span>];</div><div class=\"line\">        [subscriber sendNext:@<span class=\"number\">3</span>];</div><div class=\"line\">        </div><div class=\"line\">        [subscriber sendCompleted];</div><div class=\"line\">        </div><div class=\"line\">        <span class=\"keyword\">return</span> [RACDisposable disposableWithBlock:^&#123;</div><div class=\"line\">            <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"信号销毁\"</span>);</div><div class=\"line\">        &#125;];</div><div class=\"line\">    &#125;];</div></pre></td></tr></table></figure>\n<p><code>createSignal</code>最终会调用到以下<code>RACDynamicSignal</code>类的对象方法</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"code\"><pre><div class=\"line\">+ (RACSignal *)createSignal:(RACDisposable * (^)(<span class=\"keyword\">id</span>&lt;RACSubscriber&gt; subscriber))didSubscribe &#123;</div><div class=\"line\">\tRACDynamicSignal *signal = [[<span class=\"keyword\">self</span> alloc] init];</div><div class=\"line\">\tsignal-&gt;_didSubscribe = [didSubscribe <span class=\"keyword\">copy</span>];</div><div class=\"line\">\t<span class=\"keyword\">return</span> [signal setNameWithFormat:<span class=\"string\">@\"+createSignal:\"</span>];</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>可以看出这个方法做的事情非常简单，创建Signal对象，并将didSubscribe代码块保存起来。</p>\n<blockquote>\n<p>值得注意的是每一个信号的终点都是complete或者error，否则下一次对信号订阅操作不会生效。</p>\n</blockquote>\n<h2 id=\"订阅信号\"><a href=\"#订阅信号\" class=\"headerlink\" title=\"订阅信号\"></a>订阅信号</h2><figure class=\"highlight objectivec\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//订阅信号</span></div><div class=\"line\">   [signal subscribeNext:^(<span class=\"keyword\">id</span>  _Nullable x) &#123;</div><div class=\"line\">       <span class=\"comment\">//接收到信号时触发闭包</span></div><div class=\"line\">       <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%@\"</span>,x);</div><div class=\"line\">   &#125;];</div></pre></td></tr></table></figure>\n<p><code>subscribeNext</code>方法对刚才创建的signal进行订阅操作，<code>subscribeNext</code>的实现如下</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"code\"><pre><div class=\"line\">- (RACDisposable *)subscribeNext:(<span class=\"keyword\">void</span> (^)(<span class=\"keyword\">id</span> x))nextBlock &#123;</div><div class=\"line\">\t<span class=\"built_in\">NSCParameterAssert</span>(nextBlock != <span class=\"literal\">NULL</span>);</div><div class=\"line\">\t</div><div class=\"line\">\tRACSubscriber *o = [RACSubscriber subscriberWithNext:nextBlock error:<span class=\"literal\">NULL</span> completed:<span class=\"literal\">NULL</span>];</div><div class=\"line\">\t<span class=\"keyword\">return</span> [<span class=\"keyword\">self</span> subscribe:o];</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">- (RACDisposable *)subscribe:(<span class=\"keyword\">id</span>&lt;RACSubscriber&gt;)subscriber &#123;</div><div class=\"line\">\t<span class=\"built_in\">NSCParameterAssert</span>(subscriber != <span class=\"literal\">nil</span>);</div><div class=\"line\"></div><div class=\"line\">\tRACCompoundDisposable *disposable = [RACCompoundDisposable compoundDisposable];</div><div class=\"line\">\tsubscriber = [[RACPassthroughSubscriber alloc] initWithSubscriber:subscriber signal:<span class=\"keyword\">self</span> disposable:disposable];</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"keyword\">if</span> (<span class=\"keyword\">self</span>.didSubscribe != <span class=\"literal\">NULL</span>) &#123;</div><div class=\"line\">\t\tRACDisposable *schedulingDisposable = [RACScheduler.subscriptionScheduler schedule:^&#123;</div><div class=\"line\">\t\t\tRACDisposable *innerDisposable = <span class=\"keyword\">self</span>.didSubscribe(subscriber);</div><div class=\"line\">\t\t\t[disposable addDisposable:innerDisposable];</div><div class=\"line\">\t\t&#125;];</div><div class=\"line\"></div><div class=\"line\">\t\t[disposable addDisposable:schedulingDisposable];</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t</div><div class=\"line\">\t<span class=\"keyword\">return</span> disposable;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>内部会创建订阅者并且保存<code>nextBlock</code>代码快中的代码，并且进入到<code>RACDynamicSignal</code>的<code>subscribe</code>方法中执行在创建信号时保存的<code>didSubscribe</code>代码块中保存的代码。<br>在<code>didSubscribe</code>中已经写好了<code>[subscriber sendNext:@1];</code>方法，<code>sendNext</code>的实现如下</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"code\"><pre><div class=\"line\">- (<span class=\"keyword\">void</span>)sendNext:(<span class=\"keyword\">id</span>)value &#123;</div><div class=\"line\">\t<span class=\"keyword\">@synchronized</span> (<span class=\"keyword\">self</span>) &#123;</div><div class=\"line\">\t\t<span class=\"keyword\">void</span> (^nextBlock)(<span class=\"keyword\">id</span>) = [<span class=\"keyword\">self</span>.next <span class=\"keyword\">copy</span>];</div><div class=\"line\">\t\t<span class=\"keyword\">if</span> (nextBlock == <span class=\"literal\">nil</span>) <span class=\"keyword\">return</span>;</div><div class=\"line\"></div><div class=\"line\">\t\tnextBlock(value);</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>在执行<code>sendNext</code>方法时会执行在订阅信号时保存的<code>nextBlock</code>代码，将数字1打印出来。</p>\n"},{"title":"ReactiveCocoa之核心信号---RACSubject","date":"2017-06-07T06:04:28.000Z","_content":"## 代替代理\n`RACSubject`本身可以当做信号，也可以订阅信号。`RACSubject`常常可以用来替代代理，使用方式简单。\n![](http://i1.piimg.com/1949/04ae35a4adfec08e.jpg)\n\n原来实现代理需要六步，实现起来比较麻烦，如果使用RAC三步就可以达到代理的效果。\n\n### 创建信号\n```\nRACSubject *subject = [RACSubject subject];\n```\nRAC提供了工厂方法可以快速创建一个`RACSubject`对象。与`RACSignal`不同的是不需要在创建时就去添加`didSubscribe`闭包，也不需要在`didSubscribe `闭包中去调用`sendNext`方法。\n### 订阅信号\n```\n[subject subscribeNext:^(id  _Nullable x) {\n\t//do something\n}];\n```\n`nextBlock`闭包在执行`sendNext`方法时触发。\n### 发送信号\n```\n[subject sendNext:@3];\n```\n***\n在实际的使用中比如A需要B对象传递信息，那么A就需要代理(delegate)，则在A的.h文件中暴露`RACSubject `对象，并重写A的析构(init)方法去创建`RACSubject`对象，在A的.m文件中去订阅自己的`RACSubject `对象。\n那么在外部B只需要对A.subject使用`sendNext `即可传递信息并促发预先写好的`didSubscribe`闭包。","source":"_posts/ReactiveCocoa-RACSubject.md","raw":"---\ntitle: ReactiveCocoa之核心信号---RACSubject\ndate: 2017-06-07 14:04:28\ntags: ReactiveCocoa\n---\n## 代替代理\n`RACSubject`本身可以当做信号，也可以订阅信号。`RACSubject`常常可以用来替代代理，使用方式简单。\n![](http://i1.piimg.com/1949/04ae35a4adfec08e.jpg)\n\n原来实现代理需要六步，实现起来比较麻烦，如果使用RAC三步就可以达到代理的效果。\n\n### 创建信号\n```\nRACSubject *subject = [RACSubject subject];\n```\nRAC提供了工厂方法可以快速创建一个`RACSubject`对象。与`RACSignal`不同的是不需要在创建时就去添加`didSubscribe`闭包，也不需要在`didSubscribe `闭包中去调用`sendNext`方法。\n### 订阅信号\n```\n[subject subscribeNext:^(id  _Nullable x) {\n\t//do something\n}];\n```\n`nextBlock`闭包在执行`sendNext`方法时触发。\n### 发送信号\n```\n[subject sendNext:@3];\n```\n***\n在实际的使用中比如A需要B对象传递信息，那么A就需要代理(delegate)，则在A的.h文件中暴露`RACSubject `对象，并重写A的析构(init)方法去创建`RACSubject`对象，在A的.m文件中去订阅自己的`RACSubject `对象。\n那么在外部B只需要对A.subject使用`sendNext `即可传递信息并促发预先写好的`didSubscribe`闭包。","slug":"ReactiveCocoa-RACSubject","published":1,"updated":"2017-09-06T08:04:59.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj78qu5tj0003s2u9r6jwsd3g","content":"<h2 id=\"代替代理\"><a href=\"#代替代理\" class=\"headerlink\" title=\"代替代理\"></a>代替代理</h2><p><code>RACSubject</code>本身可以当做信号，也可以订阅信号。<code>RACSubject</code>常常可以用来替代代理，使用方式简单。<br><img src=\"http://i1.piimg.com/1949/04ae35a4adfec08e.jpg\" alt=\"\"></p>\n<p>原来实现代理需要六步，实现起来比较麻烦，如果使用RAC三步就可以达到代理的效果。</p>\n<h3 id=\"创建信号\"><a href=\"#创建信号\" class=\"headerlink\" title=\"创建信号\"></a>创建信号</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">RACSubject *subject = [RACSubject subject];</div></pre></td></tr></table></figure>\n<p>RAC提供了工厂方法可以快速创建一个<code>RACSubject</code>对象。与<code>RACSignal</code>不同的是不需要在创建时就去添加<code>didSubscribe</code>闭包，也不需要在<code>didSubscribe</code>闭包中去调用<code>sendNext</code>方法。</p>\n<h3 id=\"订阅信号\"><a href=\"#订阅信号\" class=\"headerlink\" title=\"订阅信号\"></a>订阅信号</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">[subject subscribeNext:^(id  _Nullable x) &#123;</div><div class=\"line\">\t//do something</div><div class=\"line\">&#125;];</div></pre></td></tr></table></figure>\n<p><code>nextBlock</code>闭包在执行<code>sendNext</code>方法时触发。</p>\n<h3 id=\"发送信号\"><a href=\"#发送信号\" class=\"headerlink\" title=\"发送信号\"></a>发送信号</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">[subject sendNext:@3];</div></pre></td></tr></table></figure>\n<hr>\n<p>在实际的使用中比如A需要B对象传递信息，那么A就需要代理(delegate)，则在A的.h文件中暴露<code>RACSubject</code>对象，并重写A的析构(init)方法去创建<code>RACSubject</code>对象，在A的.m文件中去订阅自己的<code>RACSubject</code>对象。<br>那么在外部B只需要对A.subject使用<code>sendNext</code>即可传递信息并促发预先写好的<code>didSubscribe</code>闭包。</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"代替代理\"><a href=\"#代替代理\" class=\"headerlink\" title=\"代替代理\"></a>代替代理</h2><p><code>RACSubject</code>本身可以当做信号，也可以订阅信号。<code>RACSubject</code>常常可以用来替代代理，使用方式简单。<br><img src=\"http://i1.piimg.com/1949/04ae35a4adfec08e.jpg\" alt=\"\"></p>\n<p>原来实现代理需要六步，实现起来比较麻烦，如果使用RAC三步就可以达到代理的效果。</p>\n<h3 id=\"创建信号\"><a href=\"#创建信号\" class=\"headerlink\" title=\"创建信号\"></a>创建信号</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">RACSubject *subject = [RACSubject subject];</div></pre></td></tr></table></figure>\n<p>RAC提供了工厂方法可以快速创建一个<code>RACSubject</code>对象。与<code>RACSignal</code>不同的是不需要在创建时就去添加<code>didSubscribe</code>闭包，也不需要在<code>didSubscribe</code>闭包中去调用<code>sendNext</code>方法。</p>\n<h3 id=\"订阅信号\"><a href=\"#订阅信号\" class=\"headerlink\" title=\"订阅信号\"></a>订阅信号</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">[subject subscribeNext:^(id  _Nullable x) &#123;</div><div class=\"line\">\t//do something</div><div class=\"line\">&#125;];</div></pre></td></tr></table></figure>\n<p><code>nextBlock</code>闭包在执行<code>sendNext</code>方法时触发。</p>\n<h3 id=\"发送信号\"><a href=\"#发送信号\" class=\"headerlink\" title=\"发送信号\"></a>发送信号</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">[subject sendNext:@3];</div></pre></td></tr></table></figure>\n<hr>\n<p>在实际的使用中比如A需要B对象传递信息，那么A就需要代理(delegate)，则在A的.h文件中暴露<code>RACSubject</code>对象，并重写A的析构(init)方法去创建<code>RACSubject</code>对象，在A的.m文件中去订阅自己的<code>RACSubject</code>对象。<br>那么在外部B只需要对A.subject使用<code>sendNext</code>即可传递信息并促发预先写好的<code>didSubscribe</code>闭包。</p>\n"},{"title":"ReactiveCocoa","date":"2017-05-12T08:57:20.000Z","_content":"## 写在前面\n> ReactiveCocoa（其简称为 RAC）是由 Github 开源的一个应用于 iOS 和 OS X 开发的新框架。RAC 具有函数式编程和响应式编程的特性。它主要吸取了 .Net 的 Reactive Extensions 的设计和实现。\n但是，相对于传统的 MVC 架构，ReactiveCocoa 的函数式编程方式的学习曲线陡峭，业界也没有丰富的图书资料，这使得大家对这种技术望而却步。\n\n以上引用自[唐巧的博客](http://blog.devtang.com/2016/01/03/reactive-cocoa-discussion/)。从自己学习的情况来看，学习ReactiveCocoa的曲线还可以接受，远没到望而却步的地步。先学习常规的用法，清楚`RACSignal`，`RACCommand`，`RACSubject`这三中信号的原理，用法，场景。\n\n再去尝试使用MVVM+RAC的结构去构建你的应用。\n\n## RAC常用类的继承关系\n<center>![](http://i2.muimg.com/1949/2b3967b71cb5d0d0.png)</center>\n\n##常用类\n[ReactiveCocoa之核心信号---RACSignal](http://104.224.135.25/2017/05/17/ReactiveCocoa-RACSignal/)\n[ReactiveCocoa之核心信号---RACCommand](http://104.224.135.25/2017/05/31/ReactiveCocoa-RACCommand/)\n[ReactiveCocoa之核心信号---RACSubject](http://104.224.135.25/2017/06/07/ReactiveCocoa-RACSubject/)","source":"_posts/ReactiveCocoa.md","raw":"---\ntitle: ReactiveCocoa\ndate: 2017-05-12 16:57:20\ntags: \n- ReactiveCocoa\n---\n## 写在前面\n> ReactiveCocoa（其简称为 RAC）是由 Github 开源的一个应用于 iOS 和 OS X 开发的新框架。RAC 具有函数式编程和响应式编程的特性。它主要吸取了 .Net 的 Reactive Extensions 的设计和实现。\n但是，相对于传统的 MVC 架构，ReactiveCocoa 的函数式编程方式的学习曲线陡峭，业界也没有丰富的图书资料，这使得大家对这种技术望而却步。\n\n以上引用自[唐巧的博客](http://blog.devtang.com/2016/01/03/reactive-cocoa-discussion/)。从自己学习的情况来看，学习ReactiveCocoa的曲线还可以接受，远没到望而却步的地步。先学习常规的用法，清楚`RACSignal`，`RACCommand`，`RACSubject`这三中信号的原理，用法，场景。\n\n再去尝试使用MVVM+RAC的结构去构建你的应用。\n\n## RAC常用类的继承关系\n<center>![](http://i2.muimg.com/1949/2b3967b71cb5d0d0.png)</center>\n\n##常用类\n[ReactiveCocoa之核心信号---RACSignal](http://104.224.135.25/2017/05/17/ReactiveCocoa-RACSignal/)\n[ReactiveCocoa之核心信号---RACCommand](http://104.224.135.25/2017/05/31/ReactiveCocoa-RACCommand/)\n[ReactiveCocoa之核心信号---RACSubject](http://104.224.135.25/2017/06/07/ReactiveCocoa-RACSubject/)","slug":"ReactiveCocoa","published":1,"updated":"2017-09-06T08:04:59.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj78qu5tk0004s2u9tr84efdl","content":"<h2 id=\"写在前面\"><a href=\"#写在前面\" class=\"headerlink\" title=\"写在前面\"></a>写在前面</h2><blockquote>\n<p>ReactiveCocoa（其简称为 RAC）是由 Github 开源的一个应用于 iOS 和 OS X 开发的新框架。RAC 具有函数式编程和响应式编程的特性。它主要吸取了 .Net 的 Reactive Extensions 的设计和实现。<br>但是，相对于传统的 MVC 架构，ReactiveCocoa 的函数式编程方式的学习曲线陡峭，业界也没有丰富的图书资料，这使得大家对这种技术望而却步。</p>\n</blockquote>\n<p>以上引用自<a href=\"http://blog.devtang.com/2016/01/03/reactive-cocoa-discussion/\" target=\"_blank\" rel=\"external\">唐巧的博客</a>。从自己学习的情况来看，学习ReactiveCocoa的曲线还可以接受，远没到望而却步的地步。先学习常规的用法，清楚<code>RACSignal</code>，<code>RACCommand</code>，<code>RACSubject</code>这三中信号的原理，用法，场景。</p>\n<p>再去尝试使用MVVM+RAC的结构去构建你的应用。</p>\n<h2 id=\"RAC常用类的继承关系\"><a href=\"#RAC常用类的继承关系\" class=\"headerlink\" title=\"RAC常用类的继承关系\"></a>RAC常用类的继承关系</h2><center><img src=\"http://i2.muimg.com/1949/2b3967b71cb5d0d0.png\" alt=\"\"></center>\n\n<p>##常用类<br><a href=\"http://104.224.135.25/2017/05/17/ReactiveCocoa-RACSignal/\">ReactiveCocoa之核心信号—RACSignal</a><br><a href=\"http://104.224.135.25/2017/05/31/ReactiveCocoa-RACCommand/\">ReactiveCocoa之核心信号—RACCommand</a><br><a href=\"http://104.224.135.25/2017/06/07/ReactiveCocoa-RACSubject/\">ReactiveCocoa之核心信号—RACSubject</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"写在前面\"><a href=\"#写在前面\" class=\"headerlink\" title=\"写在前面\"></a>写在前面</h2><blockquote>\n<p>ReactiveCocoa（其简称为 RAC）是由 Github 开源的一个应用于 iOS 和 OS X 开发的新框架。RAC 具有函数式编程和响应式编程的特性。它主要吸取了 .Net 的 Reactive Extensions 的设计和实现。<br>但是，相对于传统的 MVC 架构，ReactiveCocoa 的函数式编程方式的学习曲线陡峭，业界也没有丰富的图书资料，这使得大家对这种技术望而却步。</p>\n</blockquote>\n<p>以上引用自<a href=\"http://blog.devtang.com/2016/01/03/reactive-cocoa-discussion/\">唐巧的博客</a>。从自己学习的情况来看，学习ReactiveCocoa的曲线还可以接受，远没到望而却步的地步。先学习常规的用法，清楚<code>RACSignal</code>，<code>RACCommand</code>，<code>RACSubject</code>这三中信号的原理，用法，场景。</p>\n<p>再去尝试使用MVVM+RAC的结构去构建你的应用。</p>\n<h2 id=\"RAC常用类的继承关系\"><a href=\"#RAC常用类的继承关系\" class=\"headerlink\" title=\"RAC常用类的继承关系\"></a>RAC常用类的继承关系</h2><center><img src=\"http://i2.muimg.com/1949/2b3967b71cb5d0d0.png\" alt=\"\"></center>\n\n<p>##常用类<br><a href=\"http://104.224.135.25/2017/05/17/ReactiveCocoa-RACSignal/\">ReactiveCocoa之核心信号—RACSignal</a><br><a href=\"http://104.224.135.25/2017/05/31/ReactiveCocoa-RACCommand/\">ReactiveCocoa之核心信号—RACCommand</a><br><a href=\"http://104.224.135.25/2017/06/07/ReactiveCocoa-RACSubject/\">ReactiveCocoa之核心信号—RACSubject</a></p>\n"},{"title":"Xcode---忽略警告","date":"2017-06-12T07:45:51.000Z","_content":"## 忽略警告\n在iOS开发编码完成后，常常有一堆警告，可以使用系统提供的宏定义将警告忽略。\n\n```\n#pragma clang diagnostic push\n#pragma clang diagnostic ignored\"-Wundeclared-selector\"\n//希望忽略警告的代码区间\n#pragma clang diagnostic pop\n```\n\n## 警告名称\n警告名称可以通过警告消息在[这里](http://fuckingclangwarnings.com/)进行查找。\n\n***\n参考文章\n\n[Xcode忽略编译警告](http://blog.csdn.net/u010462316/article/details/54618178)","source":"_posts/Xcode-忽略警告.md","raw":"---\ntitle: Xcode---忽略警告\ndate: 2017-06-12 15:45:51\ntags: Xcode\n---\n## 忽略警告\n在iOS开发编码完成后，常常有一堆警告，可以使用系统提供的宏定义将警告忽略。\n\n```\n#pragma clang diagnostic push\n#pragma clang diagnostic ignored\"-Wundeclared-selector\"\n//希望忽略警告的代码区间\n#pragma clang diagnostic pop\n```\n\n## 警告名称\n警告名称可以通过警告消息在[这里](http://fuckingclangwarnings.com/)进行查找。\n\n***\n参考文章\n\n[Xcode忽略编译警告](http://blog.csdn.net/u010462316/article/details/54618178)","slug":"Xcode-忽略警告","published":1,"updated":"2017-09-06T08:04:59.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj78qu5tk0005s2u9mwuk5rou","content":"<h2 id=\"忽略警告\"><a href=\"#忽略警告\" class=\"headerlink\" title=\"忽略警告\"></a>忽略警告</h2><p>在iOS开发编码完成后，常常有一堆警告，可以使用系统提供的宏定义将警告忽略。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">#pragma clang diagnostic push</div><div class=\"line\">#pragma clang diagnostic ignored&quot;-Wundeclared-selector&quot;</div><div class=\"line\">//希望忽略警告的代码区间</div><div class=\"line\">#pragma clang diagnostic pop</div></pre></td></tr></table></figure>\n<h2 id=\"警告名称\"><a href=\"#警告名称\" class=\"headerlink\" title=\"警告名称\"></a>警告名称</h2><p>警告名称可以通过警告消息在<a href=\"http://fuckingclangwarnings.com/\" target=\"_blank\" rel=\"external\">这里</a>进行查找。</p>\n<hr>\n<p>参考文章</p>\n<p><a href=\"http://blog.csdn.net/u010462316/article/details/54618178\" target=\"_blank\" rel=\"external\">Xcode忽略编译警告</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"忽略警告\"><a href=\"#忽略警告\" class=\"headerlink\" title=\"忽略警告\"></a>忽略警告</h2><p>在iOS开发编码完成后，常常有一堆警告，可以使用系统提供的宏定义将警告忽略。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">#pragma clang diagnostic push</div><div class=\"line\">#pragma clang diagnostic ignored&quot;-Wundeclared-selector&quot;</div><div class=\"line\">//希望忽略警告的代码区间</div><div class=\"line\">#pragma clang diagnostic pop</div></pre></td></tr></table></figure>\n<h2 id=\"警告名称\"><a href=\"#警告名称\" class=\"headerlink\" title=\"警告名称\"></a>警告名称</h2><p>警告名称可以通过警告消息在<a href=\"http://fuckingclangwarnings.com/\">这里</a>进行查找。</p>\n<hr>\n<p>参考文章</p>\n<p><a href=\"http://blog.csdn.net/u010462316/article/details/54618178\">Xcode忽略编译警告</a></p>\n"},{"title":"小红点拖拽效果","date":"2017-07-28T06:58:51.000Z","_content":"## 写在前面\n之前在网上看到QQ消息列表小红点拖拽效果有人在Andorid上有人实现，最近自己也尝试使用Swift在iOS上实现下。\n![http://i4.eiimg.com/1949/ef7fbb84e27e277c.jpg]()\n\n## 动画分析\n在拖拽小红点时跟随着手指移动，同时在原位置出现一个逐渐变小的红点。超出原味一定距离，原位置的小红点直径变为0，然后消失。\n![http://i4.eiimg.com/1949/6e592cfb7a5e9e09.png]()\n","source":"_posts/小红点拖拽效果.md","raw":"---\ntitle: 小红点拖拽效果\ndate: 2017-07-28 14:58:51\ntags:\n---\n## 写在前面\n之前在网上看到QQ消息列表小红点拖拽效果有人在Andorid上有人实现，最近自己也尝试使用Swift在iOS上实现下。\n![http://i4.eiimg.com/1949/ef7fbb84e27e277c.jpg]()\n\n## 动画分析\n在拖拽小红点时跟随着手指移动，同时在原位置出现一个逐渐变小的红点。超出原味一定距离，原位置的小红点直径变为0，然后消失。\n![http://i4.eiimg.com/1949/6e592cfb7a5e9e09.png]()\n","slug":"小红点拖拽效果","published":1,"updated":"2017-09-06T08:04:59.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj78qu5tn0008s2u9jmdzpdla","content":"<h2 id=\"写在前面\"><a href=\"#写在前面\" class=\"headerlink\" title=\"写在前面\"></a>写在前面</h2><p>之前在网上看到QQ消息列表小红点拖拽效果有人在Andorid上有人实现，最近自己也尝试使用Swift在iOS上实现下。<br><img src=\"\" alt=\"http://i4.eiimg.com/1949/ef7fbb84e27e277c.jpg\"></p>\n<h2 id=\"动画分析\"><a href=\"#动画分析\" class=\"headerlink\" title=\"动画分析\"></a>动画分析</h2><p>在拖拽小红点时跟随着手指移动，同时在原位置出现一个逐渐变小的红点。超出原味一定距离，原位置的小红点直径变为0，然后消失。<br><img src=\"\" alt=\"http://i4.eiimg.com/1949/6e592cfb7a5e9e09.png\"></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"写在前面\"><a href=\"#写在前面\" class=\"headerlink\" title=\"写在前面\"></a>写在前面</h2><p>之前在网上看到QQ消息列表小红点拖拽效果有人在Andorid上有人实现，最近自己也尝试使用Swift在iOS上实现下。<br><img src=\"\" alt=\"http://i4.eiimg.com/1949/ef7fbb84e27e277c.jpg\"></p>\n<h2 id=\"动画分析\"><a href=\"#动画分析\" class=\"headerlink\" title=\"动画分析\"></a>动画分析</h2><p>在拖拽小红点时跟随着手指移动，同时在原位置出现一个逐渐变小的红点。超出原味一定距离，原位置的小红点直径变为0，然后消失。<br><img src=\"\" alt=\"http://i4.eiimg.com/1949/6e592cfb7a5e9e09.png\"></p>\n"},{"title":"为应用添加Touch ID","date":"2017-05-11T07:42:41.000Z","_content":"\n## 简介\n\nTouch ID是苹果公司的一种指纹识别技术。苹果把用户的指纹数据存放在处理器的安全区域中，充分保护用户的数据安全。除此之外，苹果还有另外一道指纹数据安全防线，以一种前所未有的硬件技术实现了对用户数据的保护。\n\n## 背景\n\n最初在2013年苹果推出的iPhone 5s上出现，解锁速度稍慢。\n在2015年苹果发布会上声明iPhone 6s采用了第二代Touch ID，识别速度更快。\n<center>![](http://i1.piimg.com/1949/1a73de8ac30b372e.jpg)</center>\n<center>相比2013年第一代Touch ID，2015年第二代Touch ID的识别面积提升了40%</center>\n\n## 使用\n```objectivec\n    LAContext *context = [[LAContext alloc] init];\n    ///从解锁屏幕成功开始的时间间隔内，去请求本地认证，将不会请求指纹验证，会直接通过验证。（最长时间5min）\n    context.touchIDAuthenticationAllowableReuseDuration = _reuserTextfield.text ? [_reuserTextfield.text integerValue] : 0;\n\n    ///失败以后的选项文字\n    context.localizedFallbackTitle = @\"余额指纹支付失败,去输密码\";\n    ///取消选项文字\n    context.localizedCancelTitle = @\"取消\";\n\n    ///检测是否支持指纹验证\n    BOOL isTouchIDEnable = [context canEvaluatePolicy:LAPolicyDeviceOwnerAuthentication error:nil];\n\n    if(isTouchIDEnable) {\n\n        ///发起指纹支付\n        [context evaluatePolicy:LAPolicyDeviceOwnerAuthentication localizedReason:@\"余额支付\" reply:^(BOOL success, NSError * _Nullable error) {\n\n            //子线程\n            NSLog(@\"%d\",[NSThread currentThread].isMainThread);\n\n            dispatch_sync(dispatch_get_main_queue(), ^{\n\n                if(success) {\n                    NSLog(@\"支付成功\");\n                    self.tipLabel.text = @\"支付成功\";\n                    return;\n                }\n\n                switch (error.code) {\n                    case LAErrorUserFallback: ///点击输入密码按钮\n                    {\n                        self.tipLabel.text = @\"输入密码\";\n                        NSLog(@\"输入密码\");\n                    }\n                        break;\n            });\n        }];\n    } else {\n        NSLog(@\"不能使用Touch ID\");\n    }\n```\n值得注意的是在指纹支付的reply代码块中的内容，默认是在子线程中执行，若有刷新UI的操作，需回到主线程执行。\n\n## 策略\n\n在验证与发起指纹支付的时候需要`Policy`参数，Apple提供了以下两种策略\n\n    LAPolicyDeviceOwnerAuthentication\n    LAPolicyDeviceOwnerAuthenticationWithBiometrics\n\n两种策略的区别我以以下的流程图说明\n![](http://i4.buimg.com/1949/b69eb46f844e5a54.png)\n注：LAPolicyDeviceOwnerAuthentication策略在Touch ID验证失败三次以后，会要求用户输入PassCode(iPhone的开屏密码)，PassCode输错6次，iPhone将被锁住1min。三次以后，会要求用户输入PassCode(iPhone的开屏密码)，PassCode输错6次，iPhone将被锁住1min。\n","source":"_posts/为应用添加Touch-ID.md","raw":"---\ntitle: 为应用添加Touch ID\ndate: 2017-05-11 15:42:41\ntags: Touch ID\n---\n\n## 简介\n\nTouch ID是苹果公司的一种指纹识别技术。苹果把用户的指纹数据存放在处理器的安全区域中，充分保护用户的数据安全。除此之外，苹果还有另外一道指纹数据安全防线，以一种前所未有的硬件技术实现了对用户数据的保护。\n\n## 背景\n\n最初在2013年苹果推出的iPhone 5s上出现，解锁速度稍慢。\n在2015年苹果发布会上声明iPhone 6s采用了第二代Touch ID，识别速度更快。\n<center>![](http://i1.piimg.com/1949/1a73de8ac30b372e.jpg)</center>\n<center>相比2013年第一代Touch ID，2015年第二代Touch ID的识别面积提升了40%</center>\n\n## 使用\n```objectivec\n    LAContext *context = [[LAContext alloc] init];\n    ///从解锁屏幕成功开始的时间间隔内，去请求本地认证，将不会请求指纹验证，会直接通过验证。（最长时间5min）\n    context.touchIDAuthenticationAllowableReuseDuration = _reuserTextfield.text ? [_reuserTextfield.text integerValue] : 0;\n\n    ///失败以后的选项文字\n    context.localizedFallbackTitle = @\"余额指纹支付失败,去输密码\";\n    ///取消选项文字\n    context.localizedCancelTitle = @\"取消\";\n\n    ///检测是否支持指纹验证\n    BOOL isTouchIDEnable = [context canEvaluatePolicy:LAPolicyDeviceOwnerAuthentication error:nil];\n\n    if(isTouchIDEnable) {\n\n        ///发起指纹支付\n        [context evaluatePolicy:LAPolicyDeviceOwnerAuthentication localizedReason:@\"余额支付\" reply:^(BOOL success, NSError * _Nullable error) {\n\n            //子线程\n            NSLog(@\"%d\",[NSThread currentThread].isMainThread);\n\n            dispatch_sync(dispatch_get_main_queue(), ^{\n\n                if(success) {\n                    NSLog(@\"支付成功\");\n                    self.tipLabel.text = @\"支付成功\";\n                    return;\n                }\n\n                switch (error.code) {\n                    case LAErrorUserFallback: ///点击输入密码按钮\n                    {\n                        self.tipLabel.text = @\"输入密码\";\n                        NSLog(@\"输入密码\");\n                    }\n                        break;\n            });\n        }];\n    } else {\n        NSLog(@\"不能使用Touch ID\");\n    }\n```\n值得注意的是在指纹支付的reply代码块中的内容，默认是在子线程中执行，若有刷新UI的操作，需回到主线程执行。\n\n## 策略\n\n在验证与发起指纹支付的时候需要`Policy`参数，Apple提供了以下两种策略\n\n    LAPolicyDeviceOwnerAuthentication\n    LAPolicyDeviceOwnerAuthenticationWithBiometrics\n\n两种策略的区别我以以下的流程图说明\n![](http://i4.buimg.com/1949/b69eb46f844e5a54.png)\n注：LAPolicyDeviceOwnerAuthentication策略在Touch ID验证失败三次以后，会要求用户输入PassCode(iPhone的开屏密码)，PassCode输错6次，iPhone将被锁住1min。三次以后，会要求用户输入PassCode(iPhone的开屏密码)，PassCode输错6次，iPhone将被锁住1min。\n","slug":"为应用添加Touch-ID","published":1,"updated":"2017-05-17T07:30:52.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj78qu5tq000fs2u9qlhedcxr","content":"<h2 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h2><p>Touch ID是苹果公司的一种指纹识别技术。苹果把用户的指纹数据存放在处理器的安全区域中，充分保护用户的数据安全。除此之外，苹果还有另外一道指纹数据安全防线，以一种前所未有的硬件技术实现了对用户数据的保护。</p>\n<h2 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h2><p>最初在2013年苹果推出的iPhone 5s上出现，解锁速度稍慢。<br>在2015年苹果发布会上声明iPhone 6s采用了第二代Touch ID，识别速度更快。</p>\n<center><img src=\"http://i1.piimg.com/1949/1a73de8ac30b372e.jpg\" alt=\"\"></center><br><center>相比2013年第一代Touch ID，2015年第二代Touch ID的识别面积提升了40%</center>\n\n<h2 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a>使用</h2><figure class=\"highlight objectivec\"><table><tr><td class=\"code\"><pre><div class=\"line\">LAContext *context = [[LAContext alloc] init];</div><div class=\"line\"><span class=\"comment\">///从解锁屏幕成功开始的时间间隔内，去请求本地认证，将不会请求指纹验证，会直接通过验证。（最长时间5min）</span></div><div class=\"line\">context.touchIDAuthenticationAllowableReuseDuration = _reuserTextfield.text ? [_reuserTextfield.text integerValue] : <span class=\"number\">0</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">///失败以后的选项文字</span></div><div class=\"line\">context.localizedFallbackTitle = <span class=\"string\">@\"余额指纹支付失败,去输密码\"</span>;</div><div class=\"line\"><span class=\"comment\">///取消选项文字</span></div><div class=\"line\">context.localizedCancelTitle = <span class=\"string\">@\"取消\"</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">///检测是否支持指纹验证</span></div><div class=\"line\"><span class=\"built_in\">BOOL</span> isTouchIDEnable = [context canEvaluatePolicy:LAPolicyDeviceOwnerAuthentication error:<span class=\"literal\">nil</span>];</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">if</span>(isTouchIDEnable) &#123;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">///发起指纹支付</span></div><div class=\"line\">    [context evaluatePolicy:LAPolicyDeviceOwnerAuthentication localizedReason:<span class=\"string\">@\"余额支付\"</span> reply:^(<span class=\"built_in\">BOOL</span> success, <span class=\"built_in\">NSError</span> * _Nullable error) &#123;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"comment\">//子线程</span></div><div class=\"line\">        <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%d\"</span>,[<span class=\"built_in\">NSThread</span> currentThread].isMainThread);</div><div class=\"line\"></div><div class=\"line\">        <span class=\"built_in\">dispatch_sync</span>(dispatch_get_main_queue(), ^&#123;</div><div class=\"line\"></div><div class=\"line\">            <span class=\"keyword\">if</span>(success) &#123;</div><div class=\"line\">                <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"支付成功\"</span>);</div><div class=\"line\">                <span class=\"keyword\">self</span>.tipLabel.text = <span class=\"string\">@\"支付成功\"</span>;</div><div class=\"line\">                <span class=\"keyword\">return</span>;</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            <span class=\"keyword\">switch</span> (error.code) &#123;</div><div class=\"line\">                <span class=\"keyword\">case</span> LAErrorUserFallback: <span class=\"comment\">///点击输入密码按钮</span></div><div class=\"line\">                &#123;</div><div class=\"line\">                    <span class=\"keyword\">self</span>.tipLabel.text = <span class=\"string\">@\"输入密码\"</span>;</div><div class=\"line\">                    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"输入密码\"</span>);</div><div class=\"line\">                &#125;</div><div class=\"line\">                    <span class=\"keyword\">break</span>;</div><div class=\"line\">        &#125;);</div><div class=\"line\">    &#125;];</div><div class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"不能使用Touch ID\"</span>);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>值得注意的是在指纹支付的reply代码块中的内容，默认是在子线程中执行，若有刷新UI的操作，需回到主线程执行。</p>\n<h2 id=\"策略\"><a href=\"#策略\" class=\"headerlink\" title=\"策略\"></a>策略</h2><p>在验证与发起指纹支付的时候需要<code>Policy</code>参数，Apple提供了以下两种策略</p>\n<pre><code>LAPolicyDeviceOwnerAuthentication\nLAPolicyDeviceOwnerAuthenticationWithBiometrics\n</code></pre><p>两种策略的区别我以以下的流程图说明<br><img src=\"http://i4.buimg.com/1949/b69eb46f844e5a54.png\" alt=\"\"><br>注：LAPolicyDeviceOwnerAuthentication策略在Touch ID验证失败三次以后，会要求用户输入PassCode(iPhone的开屏密码)，PassCode输错6次，iPhone将被锁住1min。三次以后，会要求用户输入PassCode(iPhone的开屏密码)，PassCode输错6次，iPhone将被锁住1min。</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h2><p>Touch ID是苹果公司的一种指纹识别技术。苹果把用户的指纹数据存放在处理器的安全区域中，充分保护用户的数据安全。除此之外，苹果还有另外一道指纹数据安全防线，以一种前所未有的硬件技术实现了对用户数据的保护。</p>\n<h2 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h2><p>最初在2013年苹果推出的iPhone 5s上出现，解锁速度稍慢。<br>在2015年苹果发布会上声明iPhone 6s采用了第二代Touch ID，识别速度更快。</p>\n<center><img src=\"http://i1.piimg.com/1949/1a73de8ac30b372e.jpg\" alt=\"\"></center><br><center>相比2013年第一代Touch ID，2015年第二代Touch ID的识别面积提升了40%</center>\n\n<h2 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a>使用</h2><figure class=\"highlight objectivec\"><table><tr><td class=\"code\"><pre><div class=\"line\">LAContext *context = [[LAContext alloc] init];</div><div class=\"line\"><span class=\"comment\">///从解锁屏幕成功开始的时间间隔内，去请求本地认证，将不会请求指纹验证，会直接通过验证。（最长时间5min）</span></div><div class=\"line\">context.touchIDAuthenticationAllowableReuseDuration = _reuserTextfield.text ? [_reuserTextfield.text integerValue] : <span class=\"number\">0</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">///失败以后的选项文字</span></div><div class=\"line\">context.localizedFallbackTitle = <span class=\"string\">@\"余额指纹支付失败,去输密码\"</span>;</div><div class=\"line\"><span class=\"comment\">///取消选项文字</span></div><div class=\"line\">context.localizedCancelTitle = <span class=\"string\">@\"取消\"</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">///检测是否支持指纹验证</span></div><div class=\"line\"><span class=\"built_in\">BOOL</span> isTouchIDEnable = [context canEvaluatePolicy:LAPolicyDeviceOwnerAuthentication error:<span class=\"literal\">nil</span>];</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">if</span>(isTouchIDEnable) &#123;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">///发起指纹支付</span></div><div class=\"line\">    [context evaluatePolicy:LAPolicyDeviceOwnerAuthentication localizedReason:<span class=\"string\">@\"余额支付\"</span> reply:^(<span class=\"built_in\">BOOL</span> success, <span class=\"built_in\">NSError</span> * _Nullable error) &#123;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"comment\">//子线程</span></div><div class=\"line\">        <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%d\"</span>,[<span class=\"built_in\">NSThread</span> currentThread].isMainThread);</div><div class=\"line\"></div><div class=\"line\">        <span class=\"built_in\">dispatch_sync</span>(dispatch_get_main_queue(), ^&#123;</div><div class=\"line\"></div><div class=\"line\">            <span class=\"keyword\">if</span>(success) &#123;</div><div class=\"line\">                <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"支付成功\"</span>);</div><div class=\"line\">                <span class=\"keyword\">self</span>.tipLabel.text = <span class=\"string\">@\"支付成功\"</span>;</div><div class=\"line\">                <span class=\"keyword\">return</span>;</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            <span class=\"keyword\">switch</span> (error.code) &#123;</div><div class=\"line\">                <span class=\"keyword\">case</span> LAErrorUserFallback: <span class=\"comment\">///点击输入密码按钮</span></div><div class=\"line\">                &#123;</div><div class=\"line\">                    <span class=\"keyword\">self</span>.tipLabel.text = <span class=\"string\">@\"输入密码\"</span>;</div><div class=\"line\">                    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"输入密码\"</span>);</div><div class=\"line\">                &#125;</div><div class=\"line\">                    <span class=\"keyword\">break</span>;</div><div class=\"line\">        &#125;);</div><div class=\"line\">    &#125;];</div><div class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"不能使用Touch ID\"</span>);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>值得注意的是在指纹支付的reply代码块中的内容，默认是在子线程中执行，若有刷新UI的操作，需回到主线程执行。</p>\n<h2 id=\"策略\"><a href=\"#策略\" class=\"headerlink\" title=\"策略\"></a>策略</h2><p>在验证与发起指纹支付的时候需要<code>Policy</code>参数，Apple提供了以下两种策略</p>\n<pre><code>LAPolicyDeviceOwnerAuthentication\nLAPolicyDeviceOwnerAuthenticationWithBiometrics\n</code></pre><p>两种策略的区别我以以下的流程图说明<br><img src=\"http://i4.buimg.com/1949/b69eb46f844e5a54.png\" alt=\"\"><br>注：LAPolicyDeviceOwnerAuthentication策略在Touch ID验证失败三次以后，会要求用户输入PassCode(iPhone的开屏密码)，PassCode输错6次，iPhone将被锁住1min。三次以后，会要求用户输入PassCode(iPhone的开屏密码)，PassCode输错6次，iPhone将被锁住1min。</p>\n"}],"PostAsset":[],"PostCategory":[],"PostTag":[{"post_id":"cj78qu5tk0004s2u9tr84efdl","tag_id":"cj78qu5th0002s2u9k0mwhi6t","_id":"cj78qu5tm0007s2u9a2nzr3rd"},{"post_id":"cj78qu5tb0000s2u9d8ahga7d","tag_id":"cj78qu5th0002s2u9k0mwhi6t","_id":"cj78qu5to0009s2u98xv6vf1n"},{"post_id":"cj78qu5tg0001s2u90w4fm3u2","tag_id":"cj78qu5th0002s2u9k0mwhi6t","_id":"cj78qu5tp000bs2u9hsp2wdl8"},{"post_id":"cj78qu5tj0003s2u9r6jwsd3g","tag_id":"cj78qu5th0002s2u9k0mwhi6t","_id":"cj78qu5tp000ds2u9a1z0ihcm"},{"post_id":"cj78qu5tk0005s2u9mwuk5rou","tag_id":"cj78qu5tp000cs2u923gs37e5","_id":"cj78qu5tp000es2u9ahc1tr4s"},{"post_id":"cj78qu5tq000fs2u9qlhedcxr","tag_id":"cj78qu5tr000gs2u9yacjjtlg","_id":"cj78qu5tr000hs2u9hnoljz9h"}],"Tag":[{"name":"ReactiveCocoa","_id":"cj78qu5th0002s2u9k0mwhi6t"},{"name":"Xcode","_id":"cj78qu5tp000cs2u923gs37e5"},{"name":"Touch ID","_id":"cj78qu5tr000gs2u9yacjjtlg"}]}}